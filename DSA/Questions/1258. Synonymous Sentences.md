# Problem: [1258. Synonymous Sentences](https://leetcode.com/problems/synonymous-sentences/description/)

#### Date: 14/12/2025

#### Pattern Category: Union Find / Backtracking
#### My Flawed Approach: I attempted to do DFS with previous word replacement if found in set.

#### The Key Insight: Needed to flatten the list to have all possible combinations, then perform DFS.

### Optimal Code
```java
public List<String> generateSentences(List<List<String>> synonyms, String text) {
	List<String> ans = new ArrayList();
	if (text.isEmpty()) {
		return ans;
	}
	// 1. build graph
	Map<String, Set<String>> graph = new HashMap();
	for (List<String> pair : synonyms) {
		graph.computeIfAbsent(pair.get(0), k -> new HashSet()).add(pair.get(1));
		graph.computeIfAbsent(pair.get(1), k -> new HashSet()).add(pair.get(0));
	}
	// 2. flatten each word by traversing the graph to find all of synonyms
	Map<String, Set<String>> syns = new HashMap();
	for (String key : graph.keySet()) {
		if (!syns.containsKey(key)) {
			Set<String> used = new HashSet();
			flatten(graph, key, used);
			for (String syn : used) {
				syns.put(syn, used);
			}
		}
	}
	// 3. build the permutations
	bt(ans, text.split(" "), 0, syns);
	Collections.sort(ans);
	return ans;
}

private void flatten(Map<String, Set<String>> graph, String start, Set<String> used) {
	used.add(start);
	if (graph.containsKey(start)) {
		for (String syn : graph.get(start)) {
			if (!used.contains(syn)) {
				flatten(graph, syn, used);
			}
		}
	}
}

private void bt(List<String> ans, String[] words, int index, Map<String, Set<String>> syns) {
	if (index == words.length) {
		ans.add(String.join(" ", words));
		return;
	}
	if (syns.containsKey(words[index])) {
		for (String syn : syns.get(words[index])) {
			words[index] = syn;
			bt(ans, words, index + 1, syns);
		}
	} else {
		bt(ans, words, index + 1, syns);
	}
}
```

#### Complexity: TC: O(Synonyms ^2 + text * synonyms), SC: (Synonyms ^ 2 + text)
