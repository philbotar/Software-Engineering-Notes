#### Date: 20/1/2026

#### Pattern Category: Dynamic Programming

We need 2 arrays for this question, as our state is dependent on 2 things:
1. The maximum profit when free of stock
2. The maximum profit when holding the stock

If we buy the stock on the day `i`, the profit obtained is the maximum profit without holding the stock on the previous day i - 1 `free[i - 1]` plus the profit from buying the stock `-prices[i]`.

Therefore, we can get the state transition equation for the maximum profit with different states on day `i` as:

- `free[i] = max(free[i - 1], hold[i - 1] + prices[i] - fee)`
- `hold[i] = max(hold[i - 1], free[i - 1] - prices[i])`

Once we create these two arrays, we will set `free[0] = 0` since we will make no profit with an empty hand on the first day, and set `hold[0] = -prices[0]` as we need to buy the stock on day `0` to maintain the holding state.

Then we iterate from day `1` to day `n - 1`, update `free` and `hold` and get the maximum profit from the last day `free[n - 1]`. (There is no point in ending the problem while still holding stock, we might as well sell it on the last day)

--- 
**If I'm holding stock today**, I got here by either:
1. Holding yesterday and doing nothing → `hold[i-1]`
2. Being free yesterday and buying today → `free[i-1] - prices[i]`

**If I'm free today**, I got here by either:
1. Being free yesterday and doing nothing → `free[i-1]`
2. Holding yesterday and selling today → `hold[i-1] + prices[i] - fee`

Pick whichever path gives more profit.
### Implementation
1. Create 2 Arrays of length n, free and hold. Set hold[0] = -prices[0] and free[0] = 0
2. Iterate from day 1 to day n -1, one each day i:
	- Update hold[i] to the larger of hold[i - 1] and free[i - 1] - prices[i]
	- Update free[i] to the larger of free[i - 1] and hold[i - 1] + prices[i] - fee
3. Return free[i - 1] once the iteration ends

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        int free = 0, hold = -prices[0];
        
        for (int i = 1; i < n; i++) {
            int tmp = hold;
            hold = Math.max(hold, free - prices[i]);
            free = Math.max(free, tmp + prices[i] - fee);
        }
        
        return free;
    }
}
```

### Time Complexity: O(n)
### Space Complexity: O(1)
