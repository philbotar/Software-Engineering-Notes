# 42.[ Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/solutions/7042911/max-element-left-right-clean-and-easy-code-java-javascript-python-c/?envType=study-plan-v2&envId=top-interview-150)

#### Date: 2/09/2025

#### Pattern: Two Pointer / Dynamic Programming.

#### Flawed Approach

I assumed that there was a way to ensure that you find a valid area by always comparing from left to right. Once you found a value equal or bigger, you fill in the area. This had issues when there weren't any areas bigger or as big but there wasn't any more room to go.

#### Key Insight

In order to solve this problem in O(n) time and O(1) space, we can compare from outside coming in.

Idea is that you initialise your LeftMax and RightMax from the leftmost and rightmost values. As we close in, we check whichevers smaller (starting left from 0 and right from n-1), and inc/dec accordingly. If the next value is smaller, we get the min of both the leftMax and the rightMax to identify.

1. Set our left and right variables to 0 and n-1 respectively.
2. Set leftMax to be height[left], and rightMax to be height[right].
3. As we close in, check whichevers smaller, and inc/dec that one.
   1. If we get to a new value thats even smaller, we add to the total the min(leftMax, rightMax) - height[i]. We know it cannot be bigger no matter what.
   2. Update LeftMax and RightMax each time.
4. Once both have come together, return the value.

#### Optimal Code

```
class Solution {
    public int trap(int[] height) {
        int total = 0;
        int left = 0;
        int right = height.length - 1;
        int leftMax = height[0];
        int rightMax = height[height.length - 1];

        while(left < right){
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);

            int minMax = Math.min(leftMax, rightMax);

            // Check Whichevers smaller
            if(height[left] < height[right]){
                total += minMax - height[left];
                left++;
            } else {
                total += minMax - height[right];
                right--;
            }

        }


        return total;
    }
}
```

#### Complexity

- Time Complexity: O(n) (Single Pass)
- Space Complexity: O(1) (Single variables)
