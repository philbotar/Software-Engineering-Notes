#### Date: 16/1/25

#### Pattern Category: Dynamic Programming

#### My Flawed Approach: thought to use monotonic stack and to store values up until a certain point.

We know its a dynamic programming question because: 
1. Question is asking for the maximum or minimum of something. 
2. We have to make decisions that may depend on previously made decisions. 

The Decision for this: Is it worth considering this number? If we use a number, it may contribute towards an increasing subsequence, but it may also eliminate larger elements that came before it. This is where DP comes in. 

For this question, we can have an array `dp`. This array needs to represent the length of the longest increasing subsequence that ends with the `ith` element. This is 1dimensional since it can be represented with only one variable: the index. 

For our reccurence relation: we can just go through the dp array of previously found values, and get the highest length of increaing subsequence for each number lower than it, and add 1 for our current value. 

So the recurrence relation would be: ``dp[i] = max(dp[j] + 1) for all j where nums[j] < nums[i] and j < i

And lastly, for our base case we can initialize every element of dp to 1, since each value on its own is technically an increasing subsequence. 

### Algorithm
1. Initialize an array `dp` with length `nums.length` and all elements equal to 1. `dp[i]` represents the length of the longest increasing subsequence that ends with the element at index `i`.
2. Iterate from `i = 1` to `i = nums.length - 1`. At each iteration, use a second for loop to iterate from `j = 0` to `j = i - 1` (all the elements before i). For each element before `i`, check if that element is smaller than `nums[i]`. If so, set `dp[i] = max(dp[i], dp[j] + 1)`. 
3. Return the max value from `dp`.

## Code 
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        
        int longest = 0;
        for (int c: dp) {
            longest = Math.max(longest, c);
        }
        
        return longest;
    }
}
```

## Time Complexity: O(N^2)
## Space Complexity: O(N)