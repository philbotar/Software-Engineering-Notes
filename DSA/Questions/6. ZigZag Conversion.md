# Problem: [Zigzag Conversion](https://leetcode.com/problems/zigzag-conversion/description/?envType=study-plan-v2&envId=top-interview-150)

#### Date: 6/9/25

#### Pattern Category:

### My Flawed Approach

Created a 2D Array, inputted the values in a zigzag motion into that array. Finished by traversing the array normally to create the string. Used string comparison of 'u/0000'.

### The Key Insight

We can deduce that starting from 0 we will need to traverse numRows - 1 each time for that line. So for example if rows = 4, we need to add 3 each time to get to the next zagged value. The next row down, we know we need to go 4 - 2, because theres a value being zagged BUT aswell we know to get the next sectional value too (numRows - 1). So essentially we have steps we must take each time because of the columns coming down, and if youre not the first or last value, you need to add the inbetween value.

### Optimal Code

```
class Solution {
    /**
     * Converts a string to a zigzag pattern on a given number of rows.
     *
     * @param s The input string.
     * @param numRows The number of rows for the zigzag pattern.
     * @return The string read line by line from the zigzag pattern.
     */
    public String convert(String s, int numRows) {
        // If there's only one row, the string doesn't change.
        if (numRows == 1) {
            return s;
        }

        StringBuilder result = new StringBuilder();
        int n = s.length();
        int cycleLength = 2 * (numRows - 1);

        // Iterate through each row to build the result line by line.
        for (int row = 0; row < numRows; row++) {
            // The starting index for the current row.
            int currentIndex = row;

            while (currentIndex < n) {
                // Append the character from the primary "downward" column.
                result.append(s.charAt(currentIndex));

                // If it's not the first or last row, there's an additional
                // character on the "upward" or "zagged" part of the pattern.
                if (row != 0 && row != numRows - 1) {
                    // This is the step needed to get to the "in-between" value.
                    int diagonalStep = cycleLength - (2 * row);
                    int diagonalIndex = currentIndex + diagonalStep;

                    if (diagonalIndex < n) {
                        result.append(s.charAt(diagonalIndex));
                    }
                }

                // Move to the next character in the same row, which is always
                // one full cycle length away from the current downward character.
                currentIndex += cycleLength;
            }
        }

        return result.toString();
    }
}
```

### Complexity: Time: O(n), Space: O(n)
