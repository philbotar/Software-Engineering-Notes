
#### Date: 19/1/26

#### Pattern Category: Dynamic Programming
#### My Flawed Approach: Incorrectly used count array. 

#### Intuition
Bottom-Up Dynamic Programming. 

`count[i]` tracks how many LIS end at index `i`. When we find a **longer** path via `j`, we reset `count[i]` and inherit `count[j]`. When we find an **equally long** path via another `j`, we accumulate by adding `count[j]`. This way, `count[i]` tallies all the ways to reach the longest subsequence ending at `i`.

```Java
class Solution {
    public int findNumberOfLIS(int[] nums) {
        int[] length = new int[nums.length];
        int[] count = new int[nums.length];

        Arrays.fill(length, 1);
        Arrays.fill(count, 1);

        for(int i = 0; i < nums.length; i++){
            for(int j = 0; j < i; j++){
                if(nums[j] < nums[i]){
                    if (length[j] + 1 > length[i]) {
                        length[i] = length[j] + 1; // Part 1, look for P2
                        count[i] = 0;
                    }
                    if (length[j] + 1 == length[i]) { // P2, see how they relate
                        count[i] += count[j];
                    }
                }
            }
        }

        int maxLength = 0;
        int result = 0;

        for (int len : length) {
            maxLength = Math.max(maxLength, len);
        }

        for (int i = 0; i < length.length; i++) {
            if (length[i] == maxLength) {
                result += count[i];
            }
        }

        return result;
    }
}
```


### Time Complexity: O(n^2)
### Space Complexity: O(2n) ~ O(n)