#### Date: 16/1/25

#### Pattern Category: Dynamic Programming

## Approach: Top Down Dynamic Programming

Initial Rules
1. If two strings are the same, the edit distance is zero
2. The operations (add/delete/replace) are performed if and only if a character at a certain position in word1 is not equal to the corresponding character in word2.

```javascript
Edit distance to transform "word1" to "word2" =

Minimum (Number of operations after deleting e from "word1", 
Number of operations after inserting c in "word1",
Number operations after replacing e with c in "word1") + 1
```

The + 1 is for the current operation.

## Algorithm

For the two input strings, we start by comparing each character in both. We track the current character index as word1Index and word2Index.

For every comparison, there are 2 possibilities
1. The characters in the current positions match
2. The characters in their current position do not match

In this case, we must delete, insert or replace a character in word1. 

We can do this using recursion, where we have a function `minDistanceRecur(word1, word2, word1Index, word2Index)`.

Now, lets derive the recurrence relation for each possible operation. 

1. Replace the character at `word1Index` in `word1` with the character at `word2Index` in `word2`. `minDistanceRecur(word1, word2, word1Index - 1, word2Index - 1) + 1`, where we decrease both indexes due to replacement. 
2. Insert a character at word2Index in word2 in word1. `minDistanceRecur(word1, word2, word1Index, word2Index - 1) + 1`, where we know that the character from word 2 is in word 1 now. 
3. Delete a Character at word1Index in word1. `minDistanceRecur(word1, word2, word1Index - 1, word2Index) + 1`, where the deleted char comes out of word1, and allows us to check the current word2 index if it equals the next value. 


The recurrence relation now is 
```javascript
if word1[word1Index] != word2[word2Index]:
	
	 minDistanceRecur(word1, word2, word1Index, word2Index) =
	   minimum (
			minDistanceRecur(word1, word2, word1Index - 1, word2Index - 1),
			minDistanceRecur(word1, word2, word1Index, word2Index - 1),
			minDistanceRecur(word1, word2, word1Index - 1, word2Index)
		 ) + 1

 else if word1[word1Index] == word2[word2Index]:
	minDistanceRecur(word1, word2, word1Index - 1, word2Index - 1)
```


_Base Case_

The base case is the terminating condition for the recursive function when there are no other paths to explore. In this problem, let us define all possible base cases,

1. `word1` is empty
	If `word1` is an empty string, there could be zero or more characters left in `word2`. The only possible operation is to add the characters of `word2` in `word1`. The edit distance is the number of characters in `word2`.
2. `word2` is empty
    If `word2` is an empty string, there could be zero or more characters left in `word1`. The only possible operation is to delete all the remaining characters in `word1`. The edit distance is the number of characters in `word1`.

So if we reach the end of a word and there are still other characters remaining, we return the num of characters remaining to show that we would delete the rest. 

### Memoization
To store the values to stop re-calculating, we can have a 2D array, where x is the number of characters in word1, and y is the number of characters in word2. When we reach that value, we just check if that has a number at the corresponding position. If it does we return that, otherwise we continue on. 

## Code
```java
class Solution {
    Integer memo[][];

    public int minDistance(String word1, String word2) {
        memo = new Integer[word1.length() + 1][word2.length() + 1];
        return minDistanceRecur(word1, word2, word1.length(), word2.length());
    }

    int minDistanceRecur(
        String word1,
        String word2,
        int word1Index,
        int word2Index
    ) {
        if (word1Index == 0) {
            return word2Index;
        }
        if (word2Index == 0) {
            return word1Index;
        }
        if (memo[word1Index][word2Index] != null) {
            return memo[word1Index][word2Index];
        }
        int minEditDistance = 0;
        if (word1.charAt(word1Index - 1) == word2.charAt(word2Index - 1)) {
            minEditDistance = minDistanceRecur(
                word1,
                word2,
                word1Index - 1,
                word2Index - 1
            );
        } else {
            int insertOperation = minDistanceRecur(
                word1,
                word2,
                word1Index,
                word2Index - 1
            );
            int deleteOperation = minDistanceRecur(
                word1,
                word2,
                word1Index - 1,
                word2Index
            );
            int replaceOperation = minDistanceRecur(
                word1,
                word2,
                word1Index - 1,
                word2Index - 1
            );
            minEditDistance = Math.min(
                insertOperation,
                Math.min(deleteOperation, replaceOperation)
            ) +
            1;
        }
        memo[word1Index][word2Index] = minEditDistance;
        return minEditDistance;
    }
}
```

### Time Complexity: O(M * N) 
### Space Complexity: O(M * N) for the 2D array. 