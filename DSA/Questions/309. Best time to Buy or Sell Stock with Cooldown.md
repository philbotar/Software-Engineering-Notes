#### Date: 20/12/2026

#### Pattern Category: Dynamic Programming

This problem adds a **cooldown rule**: after selling, you must wait one day before buying again. This is a state machine question where you can be 1 of 3 things. 
### The Three States

At any moment, you're in one of these states:

|State|Meaning|
|---|---|
|**Held**|You own a stock|
|**Sold**|You just sold (cooldown begins)|
|**Reset**|You're idle and free to buy|

### State Machine

```
		┌──────┐
        │      │ rest
        ▼      │
      ┌──────────┐
 ┌───►│  RESET   │
 │    └────┬─────┘
 │         │
 │         │ buy (-price)
 │         ▼
 │    ┌──────────┐
 │    │   HELD   │◄───┐
 │    └────┬─────┘    │
 │         │          │ rest
 │         │ sell     │
 │         │ (+price) │
 │         ▼          │
 │    ┌──────────┐────┘
 │    │   SOLD   │
 │    └────┬─────┘
 │         │
 └─────────┘
        cooldown (forced)
```

The key constraint: **Sold → Reset is mandatory** (the cooldown). You can't go directly from Sold back to Held.

### The Recurrence

**Sold today**: Must have held yesterday and sold now

```
sold[i] = held[i-1] + price[i]
```

**Held today**: Either held yesterday (did nothing), or was reset yesterday and bought now

```
held[i] = max(held[i-1], reset[i-1] - price[i])
```

**Reset today**: Either was reset yesterday (did nothing), or was in sold state yesterday (cooldown finished)

```
reset[i] = max(reset[i-1], sold[i-1])
```

### Final Answer

```
max(sold[n-1], reset[n-1])
```


```java
class Solution {
  public int maxProfit(int[] prices) {

    int sold = Integer.MIN_VALUE, held = Integer.MIN_VALUE, reset = 0;

    for (int price : prices) {
      int preSold = sold;

      sold = held + price;
      held = Math.max(held, reset - price);
      reset = Math.max(reset, preSold);
    }

    return Math.max(sold, reset);
  }
}
```
### Time Complexity: O(N)
### Space Complexity: O(1) 